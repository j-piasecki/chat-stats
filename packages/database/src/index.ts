import pg from 'pg'

const CONFIG = {
  user: 'chatter',
  host: 'localhost',
  database: 'chat_stats',
  password: 'password',
  port: 5432,
}

export class Database {
  private static pool = new pg.Pool(CONFIG)

  static async tryInit() {
    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS emotes(
        id VARCHAR(64) PRIMARY KEY,
        name VARCHAR(64) NOT NULL,
        animated BOOLEAN NOT NULL,
        urls JSON
      );
    `)

    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS channel_names(
        id INTEGER PRIMARY KEY,
        name VARCHAR(50) NOT NULL UNIQUE
      );
    `)

    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS user_names(
        id INTEGER PRIMARY KEY,
        name VARCHAR(50) NOT NULL UNIQUE
      );
    `)

    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS emote_usage(
        timestamp BIGINT NOT NULL,
        channel_id INTEGER,
        user_id INTEGER,
        emote_id VARCHAR(64),
        count INT,

        CONSTRAINT pk_emotes
          PRIMARY KEY(timestamp, user_id, channel_id, emote_id),

        CONSTRAINT fk_user_names
          FOREIGN KEY(user_id) REFERENCES user_names(id)
          ON DELETE CASCADE,

        CONSTRAINT fk_channel_names
          FOREIGN KEY(channel_id) REFERENCES channel_names(id)
          ON DELETE CASCADE,

        CONSTRAINT fk_emotes
          FOREIGN KEY(emote_id) REFERENCES emotes(id)
          ON DELETE CASCADE
      );
    `)

    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS user_channels(
        timestamp BIGINT NOT NULL,
        user_id INTEGER,
        channel_id INTEGER,
        count INTEGER,

        CONSTRAINT pk_user_channels
          PRIMARY KEY(timestamp, user_id, channel_id),

        CONSTRAINT fk_user_names
          FOREIGN KEY(user_id) REFERENCES user_names(id)
          ON DELETE CASCADE,

        CONSTRAINT fk_channel_names
          FOREIGN KEY(channel_id) REFERENCES channel_names(id)
          ON DELETE CASCADE
      );
    `)

    await this.pool.query(`
      CREATE TABLE IF NOT EXISTS messages(
        id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
        message VARCHAR(500) NOT NULL,
        timestamp BIGINT NOT NULL,
        channel_id INTEGER NOT NULL,
        user_id INTEGER NOT NULL,
        user_name VARCHAR(50) NOT NULL,
        subscriber BOOLEAN NOT NULL,
        moderator BOOLEAN NOT NULL,
        turbo BOOLEAN NOT NULL,
        first_message BOOLEAN NOT NULL,

        CONSTRAINT fk_channel
          FOREIGN KEY(channel_id) REFERENCES channel_names(id)
          ON DELETE CASCADE,

        CONSTRAINT fk_user
          FOREIGN KEY(user_id) REFERENCES user_names(id)
          ON DELETE CASCADE
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS channel_timestamp_index ON messages(
        channel_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS channel_user_timestamp_index ON messages(
        channel_id,
        user_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS user_timestamp_index ON messages(
        user_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS channel_timestamp_index ON emote_usage(
        channel_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS channel_user_timestamp_index ON emote_usage(
        channel_id,
        user_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS user_timestamp_index ON emote_usage(
        user_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS channel_names_index ON channel_names USING hash(
        name
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS user_names_index ON user_names USING hash(
        name
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS emote_names_index ON emotes USING hash(
        name
      );
    `)

    await this.pool.query(`
      CREATE INDEX IF NOT EXISTS user_timestamp_index ON user_channels(
        user_id,
        timestamp DESC
      );
    `)

    await this.pool.query(`
      CREATE OR REPLACE FUNCTION save_message(
        v_msg VARCHAR(500),
        v_timestamp BIGINT,
        v_channel_id INT,
        v_channel_name VARCHAR(50),
        v_user_id INT,
        v_user_name VARCHAR(50),
        v_subscriber BOOLEAN,
        v_moderator BOOLEAN,
        v_turbo BOOLEAN,
        v_first_message BOOLEAN
      )
      RETURNS void
      LANGUAGE plpgsql
      AS $$
      DECLARE
        rounded_timestamp BIGINT := (v_timestamp / 86400000) * 86400000;
      BEGIN
        INSERT INTO channel_names (id, name)
          VALUES (v_channel_id, v_channel_name)
          ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
        INSERT INTO user_names (id, name)
          VALUES (v_user_id, v_user_name)
          ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
        INSERT INTO user_channels (timestamp, user_id, channel_id, count)
          VALUES (rounded_timestamp, v_user_id, v_channel_id, 1)
          ON CONFLICT (timestamp, user_id, channel_id) DO UPDATE SET count=user_channels.count + 1;
        INSERT INTO messages (message, timestamp, channel_id, user_id, user_name, subscriber, moderator, turbo, first_message)
          VALUES (v_msg, v_timestamp, v_channel_id, v_user_id, v_user_name, v_subscriber, v_moderator, v_turbo, v_first_message);
      END; $$;
    `)

    await this.pool.query(`
      CREATE OR REPLACE FUNCTION update_emotes(
        v_data JSON,
        v_timestamp BIGINT,
        v_channel_id INT,
        v_channel_name VARCHAR(50),
        v_user_id INT,
        v_user_name VARCHAR(50)
      )
      RETURNS void
      LANGUAGE plpgsql
      AS $$
      DECLARE
        rounded_timestamp BIGINT := (v_timestamp / 86400000) * 86400000;
        emote JSON;
        v_emote_id VARCHAR(64);
        v_emote_name VARCHAR(64);
        v_emote_count VARCHAR(64);
        v_emote_urls JSON;
        v_emote_animated BOOLEAN;
      BEGIN
        INSERT INTO channel_names (id, name)
          VALUES (v_channel_id, v_channel_name)
          ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
        INSERT INTO user_names (id, name)
          VALUES (v_user_id, v_user_name)
          ON CONFLICT (id) DO UPDATE SET name = EXCLUDED.name;
        
        FOR emote IN SELECT * FROM json_array_elements(v_data)
        LOOP
          FOR v_emote_id, v_emote_name, v_emote_animated, v_emote_count, v_emote_urls IN SELECT * FROM json_to_record(emote) as x(
            id VARCHAR(64),
            name VARCHAR(64),
            animated BOOLEAN,
            count INT,
            urls JSON
          )
          LOOP
            INSERT INTO emotes(id, name, animated, urls)
            VALUES(v_emote_id, v_emote_name, v_emote_animated, v_emote_urls)
            ON CONFLICT(id) DO NOTHING;
            
            INSERT INTO emote_usage (timestamp, channel_id, user_id, emote_id, count)
            VALUES (rounded_timestamp, v_channel_id, v_user_id, v_emote_id, 1)
            ON CONFLICT (timestamp, user_id, channel_id, emote_id) DO UPDATE SET count=emote_usage.count + 1;
          END LOOP;
        END LOOP;
      END; $$;
    `)
  }
}
